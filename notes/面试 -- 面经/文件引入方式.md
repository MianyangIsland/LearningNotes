# 文件引入方式

**link和 @import**

作用: 样式的导入方式

link的使用

```js
<link href="index.css" rel="stylesheet">
```

@import的使用

```js
<style type="text/css">
@import url(index.css);
</style>
```

link和 @import的区别

1. 引入方式不同

   link处了引用样式文件,还可以引用图片等资源文件,而@import只引用样式文件

2. 加载顺序不同

   link引用CSS时,在页面载入时同时加载;@import 需要页面网页完全载入以后加载.

3. 兼容性不同

   link是XHTML标签,无兼容问题; @import是在CSS2.1提出的,低版本的浏览器不支持.

4. 对JS的支持不同

   link支持使用JavaScript控制DOM去改变样式; 而@import不支持.

**为什么link用href获取资源script和img用src**

 scr用于替换当前元素,href用于在当前文档和引用资源之间确立联系.

src:

src是source的缩写,指向外部资源的位置,指向的内容讲会嵌入当文档中当前标签所在位置;在请求scr资源时会将其指向的资源下载并应用到文档内,例如js脚本,ing图片和frame等元素.

```js
<script src ="js.js"></script> 
```

当浏览器解析到该元素时,会暂停其他资源的下载和处理,直到讲该资源加载,编译,执行完毕,图片和框架等元素也是如此,类似于讲所指向资源嵌入当前标签内.这也是为什么讲js脚本放在底部而不是头部.

href:

 href指向网络资源所在位置,建立和当前元素(锚点)或当前文档(链接)之间的链接.

 在文档中添加link标签,浏览器会识别该文档为css文件,就会并行下载并且不会停止对文档的处理.这也是为什么建议使用link方式来加载css,而不是使用@import方式.

```js
<link href="common.css" rel="stylesheet"/>
```

# js工作原理

为什么js是单线程?

这主要和js的用途有关,js是作为浏览器的脚本语言,主要是实现用户于浏览器的交互,以及操作dom,这决定了它只能是单线程,否则会带来很多复杂的同步问题.举个例子: 如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变 .

扩展:

什么是进程?

进程: 是CPU分配资源的最小单位;(是能拥有资源和独立运行的最小单位).

什么是线程?

线程: 是cpu调度的最小单位,(线程是建立在进程的基础上的一次程序运行单位,一个进程中可以有多个线程).

浏览器是多进程的?

放在浏览器中,每打开一个tab页面,其实就是新开一个进程,在这个进程,还有ui渲染线程,js引擎线程,http请求线程等.所以,浏览器是一个多进程的.

为了利用多核CPU的计算能力,HTML5提出web Worker标准,允许JavaScript脚本创建多个线程,但是子线程完全受主线程控制,且不得操作DOM.所以,这个新标准并没有改变JavaScript单线程的本质.

宏微队列执行顺序:

js中用来存储执行回调函数的队列包含2个不同特定的队列.

- **宏列队**：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调
- **微列队**：用来保存待执行的微任务（回调），比如：promise的回调、MutationObserver 的回调

JS执行时会区别这2个队列:

  JS引擎首先必须先执行所有的初始化同步任务代码.

  每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行,也就是优先级比宏任务高,且于微任务所处的代码位置无关.

eg:

```js
setTimeout(() => { //立即放入宏队列
      console.log('timeout callback1（）')
      Promise.resolve(3).then(
        value => { //立即放入微队列
          console.log('Promise onResolved3()', value)
        }
      )
    }, 0)

    setTimeout(() => { //立即放入宏队列
      console.log('timeout callback2（）')
    }, 0)

    Promise.resolve(1).then(
      value => { //立即放入微队列
        console.log('Promise onResolved1()', value)
        setTimeout(() => {
          console.log('timeout callback3（）', value)
        }, 0)
      }
    )

    Promise.resolve(2).then(
      value => { //立即放入微队列
        console.log('Promise onResolved2()', value)
      }
    )

    // Promise onResolved1() 1
    // Promise onResolved2() 2
    // timeout callback1（）
    // Promise onResolved3() 3
    // timeout callback2（）
    // timeout callback3（） 1
```

**死锁:**

死锁是指在两个或两个以上的进程在执行过程中,由于竞争资源而造成阻塞的现象,若无外力作用,它们都将无法继续执行.

产生原因:

 竞争资源引起进程死锁.

 可剥夺和非剥夺资源

  竞争非剥夺资源

  竞争临时性资源
  进程推进顺序不当.

产生条件:

1. 互斥条件: 涉及的资源是非共享的
2. 不可剥夺条件: 不能强行剥夺进程拥有的资源
3. 请求和保持条件: 进程在等待一新资源时继续占有已分配的资源

解决办法: 只要打破四个必要条件之一就能有效预防死锁产生.

**暂时性死死区:**

暂时性死区的本质就是,只要一进入当前作用域,所要使用的变量就已经存在了,但是不可获取,只有等到声明变量的那一行代码出现,才可以获取和使用该变量.

**面向对象的三个特征,分别说一下什么意思**

封装: 将对象运行所需的资源封装在程序对象中--- 基本上,是方法和数据.对象是"公布其接口".其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象.这个概念就是"不要告诉我你是怎么做的,只要做就可以了".对象可以看作是一个自我包含的原子.对象接口包括了公共的方法和初始化数据.

继承: 继承可以解决代码复用,让编程更加接近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法,所有的子类不需要重新定义这些属性和方法,只需要通过继承父类中的属性和方法.

多态: 多态是指一个引用(类型)在不同情况下的多种状态.也可以理解成:多态是指通过指向父类的引用,来调用在不同子类中实现的方法.

封装: 可以隐藏实现细节,使得代码模块化>

继承: 可以扩展已存在的代码模块(类),它们的目的都是为了 ---  代码重用.

多态就是相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。多态分为两种，一种是行为多态与对象的多态 .



# 模块化

**CommonJS规范**

CommoJS规范加载模块是同步的,只有加载完成,才能执行后面的操作.

CommonJS规范中的module,exports和require

 每个文件就是一个模块,有自己的作用域.每个模块内部,module变量代表当前模块,是一个对象,它的exports属性(即module.exports)是对外的接口.

 module.exports属性表示当前模块对外输出的接口,其他文件加载该模块,实际上就是读取module.exports变量.

为了方便,Node为每个模块提供了一个exports变量,指向module.exports.

```js
let exports = module.exports;
```

require命令用于加载模块文件.

```js
  //name.js
  exports.name = function(){return '李婷婷'}; //导出
  //getName.js
  let getName = require('name'); //引入
```

注：不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系：如下 

```js
exports = function(x){console.log(x)}
```

如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。

CommonJS模块导入用require，导出用module.exports。导出的对象需注意，如果是静态值，而且非常量，后期可能会有所改动的，请使用函数动态获取，否则无法获取修改值。导入的参数，是可以随意改动的，所以使用时要注意.

**ES6 module和CommonJS module区别**

 为CommonJS的requires语法是同步的,所以就导致了CommonJS模块规范只适合用在服务端,而ES6模块无论是在浏览器还是服务端都是可以使用的,但是在服务端中还需要遵循一些特殊的规则才能使用:

 CommonJs模块输出的是一个值的拷贝,而ES6模块输出的是值的引用.

 CommonJS模块是运行时加载的,而ES6模块是编译时输出接口,使得对JS模块进行静态分析称为了可能.

因为两个模块加载机制的不同,所以在对待循环加载的时候,它门会有不同的表现.CommonJS遇到循环依赖的时候,只会输出已经执行的部分,后续输出或者变化,是不影响已经输出的部分的.而ES6模块相反,使用import加载一个变量,变量不会被缓存,真正取值的时候就能取到最终的值>

关于模块顶层的this指向问题,在CommonJS顶层,this指向当前模块,而在ES6模块中,this指向undefined.

关于两个模块相互引用的问题: 在ES6模块当中,是支持加载CommonJS模块的.但是反过来,CommonJS并不能requiresES6模块,在NodejS中,两种模块方案是分开处理的.

#### ES6 module、CommonJS module 循环引用的问题

**参考答案：**

循环加载指的是a脚本的执行依赖b脚本，b脚本的执行依赖a脚本

1. CommonJS模块是加载时执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出。

2. ES6模块对导出模块，变量，对象是动态引用，遇到模块加载命令import时不会去执行模块，只是生成一个指向被加载模块的引用。

   CommonJS模块规范主要适用于后端Node.js，后端Node.js是同步模块加载，所以在模块循环引入时模块已经执行完毕。推荐前端工程中使用ES6的模块规范，通过安装Babel转码插件支持ES6模块引入的语法。

## 事件循环Event loop

主线程从"任务队列"中读取执行事件,这个过程是循环不断的,这个机制被称为事件循环.此机制具体如下: 主线程会不断从任务队列中按顺序去任务执行,每执行完一个任务都会检查microtask队列是否为空(执行完一个 任务的具体标志是函数执行栈为空),如果不为空则会一次性执行完所有microtask.然后再进入下一个循环取任务队列中取下一个任务执行.

**详细步骤**:

1. 选择当前要执行的宏任务队列,选择一个最先进入任务队列的宏任务,如果没有宏任务可以选择,则会跳转至microtask的执行步骤.
2. 将事件循环的当前运行宏任务设置为已选择的宏任务.
3. 运行宏任务
4. 将事件循环的当前运行任务设置为null.
5. 将运行完的宏任务从宏任务队列中移除.
6. microtasks步骤: 进入microtask检查点.
7. 更新界面渲染.
8. 返回第一步.

执行进入microtask检查的具体步骤如下:

1. 设置进入microtask检查点的标志为true.
2. 当事件循环的微任务队列不为空时,选择一个最先进入microtask队列的microtask;设置事件循环的当 前运行任务为已选择的microtask；运行microtask；设置事件循环的当前运行任务为null；将运行结束 的microtask从microtask队列中移除。 
3. 对于相应事件循环的每个环境设置对象,通知它们那些Promise为rejected.
4. 清理indexDB的事务.
5. 设置进入micrtask检查点的标志为fasle.

需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件,然后再去宏任务队列中取出一个事件.同一次事件循环中,微任务永远在宏任务之前执行.

**token能放在cookie中吗**

能,

token是在客户端频繁向服务端请求数据,服务端频繁的去数据库查询用户名和密码并进行对比,判断用户名和密码正确与否,在这样的背景之下,token便应运而生.

token的组成: uid(用户唯一的身份标识),time(当前事件的时间戳),sign(签名,token的前几位以哈希算法压缩成的一定长度的十六进制字符串).

token认证流程:

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求,去验证用户名和密码>
3. 验证成功之后,服务端签发一个token,并把它发送给客户端.
4. 客户端接收token以后会把它存储起来,比如放在cookie里或者localStorage里.
5. 客户端每次发送请求时都需要带着服务端签发的token(把token放到HTTP的Header里面).
6. 客户端收到请求后,需要验证请求里带有的token,如验证成功则返回对应的数据.

