## HTTP(1.1) 的优点有那些?

HTTP最凸出的优点是[简单,灵活和易于扩展,应用广泛和跨平台].

1.简单:

HTTP基本的报文格式就是header + body , 头部信息也是 ket-value 简单文本的形式,易于理解,降低了学习和使用的门槛.

2.灵活和易于扩展

HTTP协议里的各类请求方法,URl/URL,状态码,头字段等每个组成要求都没有被固定死,都允许开发人员**自定义和扩充**.

同时HTTP由于是工作在应用层(OSI第七层),则它下层可以随意变化.

HTTPS也就是在HTTP与TCP层之间增加了SSL/TLS安全传输层,HTTP/3甚至把TCP层换成了基于UDP的QUIC.

3.应用广泛和跨平台

## HTTP(1.1)的缺点有哪些?

HTTP协议里的优缺点一体的双刃剑,分别是[无状态,明文传输],同时还有一大缺点[不安全].

1.无状态双刃剑

无状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。 

无状态的坏处,既然服务器没有记忆能力,它在完成有关联性的操作时会非常麻烦.

例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。 

对于无状态的问题,解决方案有很多种,其中比较简单的方式用Cookie技术.

cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态.

相当于,在客户端第一次请求后,服务器会下发一个装有客户信息的[小贴纸],后续客户端请求服务器的时候,带上[小贴纸],服务器就能认得了.

![Cookie 技术](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/14-cookie%E6%8A%80%E6%9C%AF.png) 

2.明文传输双刃剑

明文意味着在传输过程中的信息,是可方便阅读的.但是这样,HTTP的所有信息都暴露在了外面,相当于信息裸奔.在传输的漫长的过程中,信息的内容都毫无隐私可言,很容易就能被窃取,如果里面有你的账号密码信息,那你号没了.

3.不安全

HTTP比较严重的缺点就是不安全:

通信使用明文(不加密),内容可能会被窃听.

不验证通信双方的身份,因此有可能遭遇伪装.

无法证明报文的完整性,所以有可能被篡改.

## HTTP/1.1的性能如何?

HTTP协议是基于TCP/IP,并且使用了[请求-应答]的通信模式,所以性能的关键就在这两点里.

1.长连接

早期HTTP/1.0性能上的一个很大的问题,那就是每发起一个请求,都要新建以此TCP连接(三次握手),而且是串行请求,做了无谓的 TCP 连接建立和断开，增加了通信开销。 

为了解决上述 TCP 连接问题，HTTP/1.1 提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。 

持久连接的特点是,只要任意一段没有明确提出断开连接,则保持TCP连接状态.

![短连接与长连接](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png) 

当然,如果某个HTTP长连接超过一定时间没有任何数据交互,服务端就会主动断开这个连接.

2.管道网络传输

HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。 

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。** 

举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求，如下图： 

![管道网络传输](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png) 

但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应.

如果服务端在处理A请求时耗时比较长,那么后续的请求处理都会被阻塞住,这称为[对头堵塞].

所以,HTTP/1.1管道解决了请求的对头阻塞,但是没有解决响应的对头阻塞.

```txt
注意!

实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以后面所有文章讨论HTTP/1.1 都是建立在没有使用管道化的前提。大家知道有这个功能，但是没有被使用就行了。
```

3.对头阻塞

[请求 - 应答]的模式加剧了HTTP的性能问题.

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」，好比上班的路上塞车。 

