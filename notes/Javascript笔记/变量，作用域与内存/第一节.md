4.1 原始值与引用值：

 原始值就是最简单的数据类型,引用值则是由多个值构成的对象.

对于引用值而言，可以随时添加，修改和删除其属性和方法,	原始值不能有属性，尽管给原始值添加属性不会报错.

注意：原始类型的初始化可以只使用原始字面量形式，如果使用的是new关键字，则js会创建一个Object类型的实例，但其行为类似原始值.

```javascript
 let name1 = 'kobe';
        let name2 = new String('lebron');
        name1.age = 27;
        name2.age = 26;
        console.log(name1.age);//undefined
        console.log(name2.age);//26
        console.log( typeof name1);//string
        console.log(typeof name2);//object
```

4.1.2复制值：

在通过变量把一个原始值赋值给另一个变量时，原始值会被赋值到新变量的位置。这两个变量可以独立使用，互不干扰.

可以理解为：原始值在进行值的赋值的时候，是给被赋值的变量新开辟一片内存，然后把这个值放在这个内存里面，然而这个值原来所在的内存并未发生改变，里面的数值也不改变.

在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映.



4.1.3 传递参数：

  ES中所有函数的参数都是按值传递的.这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样.如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样.

```javascript
function setName(obj)
       {
           obj.name = 'kobe';
           obj = new Object();
           obj.name = 'lebron';
       }

       let person = new Object();
       setName(person);
       console.log(person.name);
```

4.2.2 变量声明 :

  1.使用var的函数作用域声明：

var声明会被拿到函数或全局作用域的顶部，位于作用域中所有的代码之前，这个现象叫做“提升”。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用.

2.使用let块作用域声明 ：

let的作用域是块级的，块级作用域由最近的一对包含花括号{}界定。换句话说，if块，while块，function块，甚至连单独的块也是let声明变量的作用域.let与var的另一个不同之处是在同一个作用域内不能声明两次。重复的var声明会被忽略，重复的Let声明会抛出错误.

3.使用const的常量声明：

除了let,es6同时还增加了const关键字。使用const声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值.

